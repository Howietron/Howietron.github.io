---
title: Linux学习笔记
date: 2023-09-12 14:33:45
permalink: /pages/f78d73/
categories:
  - 运维
  - Linux学习
tags:
  - 
author: 
  name: Howietron
  link: https://github.com/Howietron
---
# Linux学习笔记

## 必须掌握的Linux命令

### shell

​		通过SHELL，用户可以直接与操作系统进行交互，执行命令、管理文件、启动和停止进程等。此外，SHELL还允许用户编写脚本来完成复杂的任务，例如自动化部署、数据处理、系统管理等。SHELL是操作系统中非常重要和强大的工具，它使用户能够更灵活地控制和操作系统。

​		在Linux和Unix系统中，常见的SHELL包括Bash（Bourne Again SHell）、C Shell（csh）、Korn Shell（ksh）等。每个SHELL都有自己的特点和语法，但它们都提供了类似的基本功能，如命令执行、文件操作、进程管理等。

​		现在包括[红帽](https://baike.baidu.com/item/Red%20Hat/7360805?fr=ge_ala)系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：

> ​		**1.通过上下方向键来调取执行过的Linux命令；**
>
> ​		**2.命令或参数仅需输入前几位就可以用Tab键补全；**
>
> ​		**3.具有强大的批处理脚本；**
>
> ​		**4.具有实用的环境变量功能。**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/07/0920230709222246.png" alt="image-20230709222226336" style="zoom:67%;" />



### 命令执行的必备知识

**1.man**:man命令帮助信息的界面中，所包含的常用操作按键及其作用如下表格：

| 按键      | 作用                               |
| --------- | ---------------------------------- |
| 空格键    | 向下翻一页                         |
| PaGe down | 向下翻一页                         |
| PaGe up   | 向上翻一页                         |
| home      | 直接前往首页                       |
| end       | 直接前往尾页                       |
| /         | 从上至下搜索某个关键词，如“/linux” |
| ?         | 从下至上搜索某个关键词，如“?linux” |
| n         | 定位到下一个搜索到的关键词         |
| N         | 定位到上一个搜索到的关键词         |
| q         | 退出帮助文档                       |

**2.man命令中帮助信息的结构以及意义**

| 结构名称    | 代表意义                 |
| ----------- | ------------------------ |
| NAME        | 命令的名称               |
| SYNOPSIS    | 参数的大致使用方法       |
| DESCRIPTION | 介绍说明                 |
| EXAMPLES    | 演示（附带简单说明）     |
| OVERVIEW    | 概述                     |
| DEFAULTS    | 默认的功能               |
| OPTIONS     | 具体的可用选项（带介绍） |
| ENVIRONMENT | 环境变量                 |
| FILES       | 用到的文件               |
| SEE ALSO    | 相关的资料               |
| HISTORY     | 维护历史与联系方式       |

**3.常用组合键**

​		**Ctrl+C组合键**：当同时按下键盘上的Ctrl和字母C的时候，意味着终止当前进程的运行

​		**Ctrl+D组合键**：当同时按下键盘上的Ctrl和字母D的时候，表示键盘输入结束。

​		**Ctrl+L组合键**：当同时按下键盘上的Ctrl和字母L的时候，会清空当前终端中已有的内容（相当于清屏操作）。

### 常用命令

**1.echo：**在终端设备上输出字符串或变量提取后的值

**2.date：**显示或设置系统的时间与日期

```
[root@linux ~]# date "+%Y-%m-%d %H:%M:%S"
2020-09-05 09:14:35
```

**3.timedatectl：**用于设置系统的时间

| 参数           | 作用         |
| -------------- | ------------ |
| status         | 显示状态信息 |
| list-timezones | 列出已知时区 |
| set-time       | 设置系统时间 |
| set-timezone   | 设置生效时区 |

**4.wget：**用于在终端命令行中下载网络文件

| 参数 | 作用                                 |
| ---- | ------------------------------------ |
| -b   | 后台下载模式                         |
| -P   | 下载到指定目录                       |
| -t   | 最大尝试次数                         |
| -c   | 断点续传                             |
| -p   | 下载页面内所有资源，包括图片、视频等 |
| -r   | 递归下载                             |

**5.ps：**查看系统中的进程状态

| 参数 | 作用                               |
| ---- | ---------------------------------- |
| -a   | 显示所有进程（包括其他用户的进程） |
| -u   | 用户以及其他详细信息               |
| -x   | 显示没有控制终端的进程             |

​	**R（运行）**：进程正在运行或在运行队列中等待。

​	**S（中断）**：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。

​	**D（不可中断）**：进程不响应系统异步信号，即便用kill命令也不能将其中断。

​	**Z（僵死）**：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。

​	**T（停止）**：进程收到停止信号后停止运行。

**6.pstree:**

**7.top：**用于动态地监视进程活动及系统负载等信息

**8.kill:**终止某个指定PID值的服务进程

```
kill - 9 进程id   #最高级别强制杀死
```

**9.killall:**终止某个指定名称的服务所对应的全部进程

### 资源状态检测命令

**1.ifconfig:**获取网卡配置与网络状态等信息

ifconfig命令主要用于旧版本的Linux和Unix操作系统，用于配置和显示网络接口的信息

**2.ip:**显示与配置网卡

ip命令主要用于最新版本的Linux操作系统，提供更多功能和选项，用于配置网络接口、路由表和其他网络相关的设置

**3.netstat:**显示如网络连接、路由表、接口状态等的网络相关信息

|参数|作用|
| :--- | ------------------------ |
| -a   | 显示所有连接中的Socket   |
| -p   | 显示正在使用的Socket信息 |
| -t   | 显示TCP协议的连接状态    |
| -u   | 显示UDP协议的连接状态    |
| -n   | 使用IP地址，不使用域名   |
| -l   | 仅列出正在监听的服务状态 |
| -i   | 显示网卡列表信息         |
| -r   | 显示路由表信息           |

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144129.png" alt="image-20230709212615747" />

**4.uanme：**查看系统内核版本与系统架构等信息

**5.uptime：**查看系统负载信息

**6.who：**查看谁登录了系统

**7.free -h:**查看系统内存空间

|       | 内存总量 | 已用量 | 空闲量 | 共享使用的内存量 | 磁盘缓存的内存量 | 缓存的内存量 | 可用量    |
| ----- | -------- | ------ | ------ | ---------------- | ---------------- | ------------ | --------- |
|       | total    | used   | free   | shared           | buffers          | buff/cache   | available |
| Mem:  | 1.9Gi    | 1.4Gi  | 99Mi   | 20Mi             | 450Mi            | 348Mi        |           |
| Swap: | 2.0Gi    | 80Mi   | 1.9Gi  |                  |                  |              |           |

**8.last：**显示用户历史登录情况

**7.history**:查看和管理执行过的命令

| 参数 | 作用                       |
| ---- | -------------------------- |
| -a   | 保存命令记录               |
| -c   | 清空命令记录               |
| -d   | 删除指定序号的命令记录     |
| -n   | 读取命令记录               |
| -r   | 读取命令记录到缓冲区       |
| -s   | 添加命令记录到缓冲区       |
| -w   | 将缓冲区信息写入到历史文件 |

```
# 修改history显示格式，显示执行时间
[root@linux ~]# vim .bashrc
HISTTIMEFORMAT="%F %T "
export HISTTIMEFORMAT
[root@linux ~]# source .bashrc
```

**8.sosreport:**用于收集系统配置及架构信息

**9.fdisk:**磁盘分区管理（后面会细讲）

### 查找文件相关资源



<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/07/0920230709222932.png" alt="image-20230709193840520" />

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/07/0920230709222938.png" alt="image-20230709194549937" />

**1.pwd：**用于查看当前用户所处目录

**2.cd:**切换目录

**3.ls：**于显示目录中的文件信息

**4.tree：**以树状图的形式列出目录内容及结构

**5.find:**按照指定条件来查找文件所对应的位置

```
find / -user linux -exec cp -a {} /root/find \;
```

**6.which：**查看命令所处位置

**7.locate：**用于按照名称快速搜索文件所对应的位置，第一次使用locate命令之前，记得先执行updatedb命令来生成索引数据库



### **文本处理命令**

**1.cat:**查看纯文本文件

```
cat -n intitial-setup-ks.cfg   #查看时添加行号
```

**2.more:**用于查看纯文本文件（内容较多的）

**3.less:**分页显示文件内容

**4.head:**查看文件前几行

**5.tail:**查看文件后几行（比较适合实时查看日志）

**6.tr:**用于替换文本内容中的字符

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/07/0920230709222958.png" alt="image-20230709201835081" />

| 参数 | 作用                                           |
| ---- | ---------------------------------------------- |
|-c| 反选字符串1的补集 |
|-d |删除字符串1中出现的所有字符 |
|-s |删除所有重复出现的字符序列 |
|-t |将字符串1截断为字符串2的长度|
**7.wc：**统计文件数据行数

**8.stat:**详细显示文件信息

**9.grep:**用于按行提取文本信息

| 参数 | 作用                                           |
| ---- | ---------------------------------------------- |
| -b   | 将可执行文件(binary)当作文本文件（text）来搜索 |
| -c   | 仅显示找到的行数                               |
| -i   | 忽略大小写                                     |
| -n   | 显示行号                                       |
| -v   | 反向选择——仅列出没有“关键词”的行。             |

**10.cut:**按“列”提取文本内容

**11.diff：**比较两个文件的差异内容

```
duff --brief diff_A.txt diff_N.txt #判断文件是否有差异
duff -c diff_A.txt diff_N.txt      #查看具体不同的内容
```

**12.uniq：**对文本内容进行去重

**13.sort：**对文本内容进行排序

| 参数 | 作用           |
| ---- | -------------- |
| -f   | 忽略大小写     |
| -b   | 忽略缩进与空格 |
| -n   | 以数值型排序   |
| -r   | 反向排序       |
| -u   | 去除重复行     |
| -t   | 指定间隔符     |
| -k   | 设置字段范围   |

### 文件目录管理

**1.touch:**用于创建空白文件或设置文件的时间

| 参数 | 作用                      |
| ---- | ------------------------- |
| -a   | 仅修改“读取时间”（atime） |
| -m   | 仅修改“修改时间”（mtime） |
| -d   | 同时修改atime与mtime      |

**2.mkdir：**创建空白目录

| 参数 | 作用     |
| ---- | -------- |
| -p   | 递归创建 |

```
mkdir -p /a/{a1,a2,a3}/b
```

**3.cp:**复制文件或目录

| 参数 | 作用                                         |
| ---- | -------------------------------------------- |
| -p   | 保留原始文件的属性                           |
| -d   | 若对象为“链接文件”，则保留该“链接文件”的属性 |
| -r   | 递归持续复制（用于目录）                     |
| -i   | 若目标文件存在则询问是否覆盖                 |
| -a   | 相当于-pdr（p、d、r为上述参数）              |

**4.mv:**移动或者重命名

**5.rm：**删除文件或者目录

| 参数 | 作用       |
| ---- | ---------- |
| -f   | 强制执行   |
| -i   | 删除前询问 |
| -r   | 删除目录   |
| -v   | 显示过程   |

**6.dd:用于按照指定大小和个数的数据块来复制文件或转换文件**

**7.file:用于查看文件的类型**

**8.tar：用于对文件进行打包压缩或解压**

 tar命令中的参数及其作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| -c   | 创建压缩文件           |
| -x   | 解开压缩文件           |
| -t   | 查看压缩包内有哪些文件 |
| -z   | 用Gzip压缩或解压       |
| -j   | 用bzip2压缩或解压      |
| -v   | 显示压缩或解压的过程   |
| -f   | 目标文件名             |
| -p   | 保留原始的权限与属性   |
| -P   | 使用绝对路径来压缩     |
| -C   | 指定解压到的目录       |

**记忆方式：**

1.vf 参数几乎是必加的，v 显示操作过程，f 指定操作文件。（f一定要有，v视情况可加可不加）
2.x 为解压缩，extract。c 为压缩，compress。
3.如果文件是 .bz/.bz2 文件，使用 j 参数，支持bzip2解压文件（bz、bz2后缀的文件）。
4.如果文件是 .gz 文件，使用 z 参数，支持gzip解压文件（gz后缀的文件）。

压缩一个文件


```sh
[root@linuxprobe ~]# tar czvf etc.tar.gz /etc
tar: Removing leading `/' from member names
/etc/
/etc/fstab
/etc/crypttab
/etc/mtab
/etc/fonts/
/etc/fonts/conf.d/
/etc/fonts/conf.d/65-0-madan.conf
/etc/fonts/conf.d/59-liberation-sans.conf
/etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf
/etc/fonts/conf.d/59-liberation-mono.conf
/etc/fonts/conf.d/66-sil-nuosu.conf
………………省略部分压缩过程信息………………
```

解压一个文件

```
[root@linux ~]# mkdir /root/etc
[root@linux ~]# tar xzvf etc.tar.gz -C /root/etc
etc/
etc/fstab
etc/crypttab
etc/mtab
etc/fonts/
etc/fonts/conf.d/
etc/fonts/conf.d/65-0-madan.conf
etc/fonts/conf.d/59-liberation-sans.conf
etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf
etc/fonts/conf.d/59-liberation-mono.conf
etc/fonts/conf.d/66-sil-nuosu.conf
etc/fonts/conf.d/65-1-vlgothic-gothic.conf
etc/fonts/conf.d/65-0-lohit-bengali.conf
etc/fonts/conf.d/20-unhint-small-dejavu-sans.conf
………………省略部分解压过程信息………………
```



## 管道符、重定向与环境变量

### 输入输出重定向

输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。

**输入重定向中用到的符号及其作用**

| 符号                 | 作用                                         |
| -------------------- | -------------------------------------------- |
| 命令 < 文件          | 将文件作为命令的标准输入                     |
| 命令 << 分界符       | 从标准输入中读入，直到遇见分界符才停止       |
| 命令 < 文件1 > 文件2 | 将文件1作为命令的标准输入并将标准输出到文件2 |

**输出重定向中用到的符号及其作用**

| 符号                               | 作用                                                 |
| ---------------------------------- | ---------------------------------------------------- |
| 命令 > 文件                        | 将标准输出重定向到一个文件中（清空原有文件的数据）   |
| 命令 2> 文件                       | 将错误输出重定向到一个文件中（清空原有文件的数据）   |
| 命令 >> 文件                       | 将标准输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 2>> 文件                      | 将错误输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 >> 文件 2>&1 或 命令 &>> 文件 |                                                      |

### 管道符

​		执行格式为“命令A | 命令B，**把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入**，管道符可以在一个命令组合中使用多次如：“命令A | 命令B | 命令C”。

### 命令行的通配符

​		通配符就是通用的匹配信息的符号，比如星号（*）代表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符。

**Linux系统中的通配符及含义**

| 通配符      | 含义           |
| ----------- | -------------- |
| *           | 任意字符       |
| ?           | 单个任意字符   |
| [a-z]       | 单个小写字母   |
| [A-Z]       | 单个大写字母   |
| [a-Z]       | 单个字母       |
| [0-9]       | 单个数字       |
| [[:alpha:]] | 任意字母       |
| [[:upper:]] | 任意大写字母   |
| [[:lower:]] | 任意小写字母   |
| [[:digit:]] | 所有数字       |
| [[:alnum:]] | 任意字母加数字 |
| [[:punct:]] | 标点符号       |

### 常用的转义字符

**4个最常用的转义字符如下所示。**

> **反斜杠（\）**：使反斜杠后面的一个变量变为单纯的字符。
>
> **单引号（' '）**：转义其中所有的变量为单纯的字符串。
>
> **双引号（" "）**：保留其中的变量属性，不进行转义处理。
>
> **反引号（` `）**：把其中的命令执行后返回结果。

### 环境变量

**一条命令在Linux中执行分为以下四个步骤：**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144157.png" alt="image-20230715204409375" />



**<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144201.png" alt="image-20230715205515357" />**

**创建别名**

```
alias 别名='命令'

```



**取消别名**

## vim编辑器与shell脚本

### vim编辑器的使用

#### **编写简单文档**

#### **配置主机名称**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144212.png" alt="image-20230824183632200" />

#### **配置网卡信息**

1.可以使用nmtui进入图形化界面编辑网卡信息

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144216.png" alt="image-20230824183850524" />



####  **配置软件仓库**

```sh
[root@venus ~]# cd /etc/yum.repos.d/ 
[root@venus ~]# vim rhcsa.repo 
[BaseOS] 
name=BaseOS 
baseurl=http://content/rhel8.0/x86_64/dvd/BaseOS 
enabled=1 
gpgcheck=0 
[AppStream] 
name=AppStream 
baseurl=http://content/rhel8.0/x86_64/dvd/AppStream 
enabled=1 
gpgcheck=0
```

可以使用以下命令验证

```
yum list
```



### **编写脚本**

### **流程控制语句**

### **计划任务服务程序**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144220.png" alt="image-1220230912144220" />

问题：

1.一个&和一个|是好像也是逻辑运算符



## 用户身份与文件权限

### **用户身份与能力**

#### **用户**

在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。

> **管理员UID为0**：系统的管理员用户。
>
> **系统用户UID为1～999**：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。
>
> **普通用户UID从1000开始**：是由管理员创建的用于日常工作的用户。
>
> **注意：**UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）否则会出现错误。

**id命令**

id命令用于显示用户的详细信息

```
[root@linux ~]# id root
uid=0(root) gid=0(root) groups=0(root)  
```

#### **用户组**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144223.png" alt="image-20230825213148617" />

#### 用户的新增及管理

##### **useradd命令**

用于创建新的用户账户，默认的用户家目录会被存放在/home目录中，默认的[Shell](https://www.linuxcool.com/)解释器为/bin/bash，而且默认会创建一个与该用户同名的基本用户组。

useradd命令中的参数以及作用

| 参数 | 作用                                     |
| ---- | ---------------------------------------- |
| -d   | 指定用户的家目录（默认为/home/username） |
| -e   | 账户的到期时间，格式为YYYY-MM-DD.        |
| -u   | 指定该用户的UID                          |
| -g   | 指定一个初始的用户基本组（必须已存在）   |
| -G   | 指定一个或多个扩展用户组                 |
| -N   | 不创建与用户同名的基本用户组             |
| -s   | 指定该用户的默认Shell解释器              |

**示例：**

创建指定的用户信息：
```
[root@linux ~]# useradd howie
```

创建指定的用户信息，但不创建家目录，亦不让登录系统：
```
[root@linux ~]# useradd -M -s /sbin/nologin howie
```

创建指定的用户信息，并自定义UID值：

```
[root@linux ~]# useradd -u 6688 howie
```

创建指定的用户信息，并追加指定组为该账户的扩展组：
```
[root@linux ~]# useradd -G root howie
```

创建指定的用户信息，并指定过期时间：
```
[root@linux ~]# useradd -e "2024/01/01" howie
```

##### **userdel命令**

用于删除已有的用户账户

**userdel命令中的参数以及作用**

| 参数 | 作用                     |
| ---- | ------------------------ |
| -f   | 强制删除用户             |
| -r   | 同时删除用户及用户家目录 |

```
[root@linux ~]# userdel linuxprobe
[root@linux ~]# id linuxprobe
id: linux: no such user
```

##### **usermod命令**

用于修改用户的属性。

**usermod命令中的参数以及作用**

| 参数  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| -c    | 填写用户账户的备注信息                                       |
| -d -m | 参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去 |
| -e    | 账户的到期时间，格式为YYYY-MM-DD                             |
| -g    | 变更所属用户组                                               |
| -G    | 变更扩展用户组                                               |
| -L    | 锁定用户禁止其登录系统                                       |
| -U    | 解锁用户，允许其登录系统                                     |
| -s    | 变更默认终端                                                 |
| -u    | 修改用户的UID                                                |

示例：

将用户howie加入到root用户组中，这样扩展组列表中则会出现root用户组的字样，而基本组不会受到影响：

```
[root@linux ~]# usermod -G root linuxprobe
[root@linux ~]# id linuxprobe
uid=1000(howie) gid=1000(howie) groups=1000(howie),0(root)
```

用-u参数修改howie用户的UID号码值：

```
[root@linux ~]# usermod -u 8888 linuxprobe
[root@linux ~]# id linuxprobe
uid=8888(howie) gid=1000(howie) groups=1000(howie),0(root)
```

解释器终端由默认的/bin/bash修改为/sbin/nologin,使其无法通过shell终端登录（切换身份也不行）

```
[root@linux ~]# usermod -s /sbin/nologin howie
[root@linux ~]# su - howie
This account is currently not available.
```

#### 用户组的新增及管理

##### **groupadd命令**

用于创建新的用户组。

```
[root@linux ~]# groupadd ronny
```

##### groupmems命令

管理用户主要组群的成员。

| 参数 | 作用                 |
| ---- | -------------------- |
| -a   | 添加用户为组成员     |
| -d   | 从组成员中删除用户   |
| -l   | 列出组群的成员       |
| -p   | 从组群中清除所有成员 |

示例

设置用户zhangsan的主要组群为root

```
[root@linux ~]# groupmems -g root -a zhangsan
```

列出主要组群的成员：
```
[root@linuxcool ~]# groupmems -l
```

#### **passwd命令**

用于修改用户的密码

```
[root@linux ~]# passwd
Changing password for user root.
New password: 此处输入密码值
Retype new password: 再次输入进行确认
passwd: all authentication tokens updated successfully.
```

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144232.png" alt="image-20230826141941502" />

### **文件权限与归属**

在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。

**文件权限与归属**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144236.png" alt="image-20230826160737306" />

**文件权限数字表示**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144240.png" alt="image-20230826161042248" />

**通过ls命令查看到的文件属性信息**

常见的文件类型包括普通文件（-）、目录文件（d）、链接文件（l）、管道文件（p）、块设备文件（b）以及字符设备文件（c），字符设备文件一般是指硬件设备，比如鼠标、键盘、光驱、硬盘等，在/dev/目录中最为常见。

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144242.png" alt="image-20230826161104003" />



### **文件的特殊权限**

#### **三个特殊权限**

**SUID-Set UID:**设置在own位置，对可执行文件有效，

1. SUID权限仅对可执行文件有效
2. 执行者对于该可执行文件需要具有x权限
3. 在执行过程中，调用者会暂时获得该文件的拥有者权限
4. 该权限只在程序执行的过程中有效

**SGID-Set GID：**设置在group位置

1. 既可以作用于目录，也可以作用于可执行文件
2. 只要父目录有SGID权限，所有的子目录都会递归继承
3. 执行者对于该可执行文件需要具有x权限
4. 在执行过程中，调用者会暂时获得该文件的所属组权限

**SBIT-Sticky Bit:**设置在other位置，

​	当用户在该目录下建立文件或目录时，仅有自己与 root才有权力删除。 

最具有代表的就是/tmp目录，任何人都可以在/tmp内增加、修改文件（因为权限全是rwx），但仅有该文件/目录建立者与 root能够删除自己的目录或文件。

#### **chmod命令**

用于设置文件的一般权限及特殊权限

**SUID、SGID、SBIT特殊权限的设置参数**

| 参数 | 作用         |
| ---- | ------------ |
| u+s  | 设置SUID权限 |
| u-s  | 取消SUID权限 |
| g+s  | 设置SGID权限 |
| g-s  | 取消SGID权限 |
| o+t  | 设置SBIT权限 |
| o-t  | 取消SBIT权限 |

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144250.png" alt="image-20230828150914629" />

**示例：**

设定某个文件的权限为775
```
[root@linux ~]# chmod 775 File.cfg
```

设定某个文件让任何人都可以读取
```
[root@linux ~]# chmod a+r File.cfg
```

设定某个目录及其内子文件任何人都可以读取和读取：
```
[root@linux ~]# chmod -R a+r Dir
```

设定某个二进制命令文件上新增SUID特殊权限位：
```
[root@linux ~]# chmod u+s /sbin/reboot
```

#### **chown**命令

用于设置文件的所有者和所有组，语法格式为“chown 所有者:所有组 文件名”

```
[root@linux ~]# chown howie:howie anaconda-ks.cfg 
[root@linux ~]# ls -l anaconda-ks.cfg 
-rwxrw----. 1 howie howie 1407 Jul 21 05:09 anaconda-ks.cfg
```



### **文件的隐藏属性**

是一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉，这在一定程度上阻止了黑客篡改系统日志的图谋，隐藏权限的专用设置命令是chattr，专用查看命令是lsattr。

#### **chattr命令**

用于设置文件的隐藏权限

**常见权限**

| 参数 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| i    | 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件 |
| a    | 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）     |
| S    | 文件内容在变更后立即同步到硬盘（sync）                       |
| s    | 彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）      |
| A    | 不再修改这个文件或目录的最后访问时间（atime）                |
| b    | 不再修改文件或目录的存取时间                                 |
| D    | 检查压缩文件中的错误                                         |
| d    | 使用dump命令备份时忽略本文件/目录                            |
| c    | 默认将文件或目录进行压缩                                     |
| u    | 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复         |
| t    | 让文件系统支持尾部合并（tail-merging）                       |
| x    | 可以直接访问压缩文件中的内容                                 |

示例

给指定文件添加隐藏属性

```
[root@linuxcool ~]# chattr +i File.cfg
```

#### lsattr命令

用于查看文件的隐藏权限

给指定文件添加隐藏属性： [root@linuxcool ~]# chattr +i File.cfg 从指定文件移除隐藏属性：从指定文件移除隐藏属性：

```
[root@linuxcool ~]# chattr -i File.cfg 
```

### **文件访问控制列表**

一般权限、特殊权限、隐藏权限其实有一个共性—权限是针对某一类用户设置的，能够对很多人同时生效。如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。

#### **setfacl命令**

用于管理文件的ACL权限规则

setfacl命令中的参数以及作用

| 参数 | 作用             |
| ---- | ---------------- |
| -m   | 修改权限         |
| -M   | 从文件中读取权限 |
| -x   | 删除某个权限     |
| -b   | 删除全部权限     |
| -R   | 递归子目录       |

例如，我们原本是无法进入/root目录中的，现在为普通用户单独设置一下权限,使其能够进行访问：

```
[root@linux ~]# setfacl -Rm u:wukong:rwx /root
```

#### getfacl命令

用于查看文件的ACL权限规则

```
[root@linux ~]# getfacl /root
ggetfacl: Removing leading '/' from absolute path names
# file: root
# owner: root
# group: root
user::r-x
user:linux:rwx
group::r-x
mask::rwx
other:
```



### **su命令与sudo服务**



## 存储结构与磁盘管理

###  **一切从** “/”开始

**1.Linux文件系统目录遵循FHS(Filesystem Hierarchy Standard)文件系统层次化标准**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144255.png" alt="image-20230729184652014" />

**2.FHS的发展**



<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912151635.png" alt="image-20230729184934469" />

**3.目录命名规则**

**Linux系统中常见的目录名称以及相应内容:**

| 目录名称    | 应放置文件的内容                                             |
| ----------- | ------------------------------------------------------------ |
| /boot       | 开机所需文件—内核、开机菜单以及所需配置文件等                |
| /dev        | 以文件形式存放任何设备与接口                                 |
| /etc        | 配置文件                                                     |
| /home       | 用户主目录                                                   |
| /bin        | 存放单用户模式下还可以操作的[命令](https://www.linuxcool.com/) |
| /lib        | 开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数    |
| /sbin       | 开机过程中需要的命令                                         |
| /media      | 用于挂载设备文件的目录                                       |
| /opt        | 放置第三方的软件                                             |
| /root       | 系统管理员的家目录                                           |
| /srv        | 一些网络服务的数据文件目录                                   |
| /tmp        | 任何人均可使用的“共享”临时目录                               |
| /proc       | 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等       |
| /usr/local  | 用户自行安装的软件                                           |
| /usr/sbin   | Linux系统开机时不会使用到的软件/命令/[脚本](https://www.linuxcool.com/) |
| /usr/share  | 帮助与说明文件，也可放置共享文件                             |
| /var        | 主要存放经常变化的文件，如日志                               |
| /lost+found | 当文件系统发生错误时，将一些丢失的文件片段存放在这里         |

**4.绝对路径 和 相对路径**

**绝对路径（absolute path）**：首先坐飞机来到中国，到了北京后出首都机场，坐机场快轨到三元桥，然后换乘10号线到潘家园站，出站后坐34路公交车到农光里，下车后路口左转。

**相对路径（relative path）**：前面路口左转。

### **物理设备的命名规则**

**1.设备命名规则**

常见的硬件设备及其文件名称

| 硬件设备      | 文件名称                     |
| ------------- | ---------------------------- |
| IDE设备       | /dev/hd[a-d]                 |
| SCSI/SATA/U盘 | /dev/sd[a-z]                 |
| NNME设备      | /dev/nvme0n1,/dev/nvme1n1... |
| virtio设备    | /dev/vd[a-z]                 |
| 软驱          | /dev/fd[0-1]                 |
| 打印机        | /dev/lp[0-15]                |
| 光驱          | /dev/cdrom                   |
| 鼠标          | /dev/mouse                   |
| 磁带机        | /dev/st0或/dev/ht0           |



**2.磁盘设备名称解释**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144302.png" alt="image-20230729185312997" />

==注意：==sda1表示第一个分区，sda2表示第二个分区，以此类推。当数字大于4时，通常表示扩展分区或逻辑分区。sda5通常是指扩展分区中的第一个逻辑分区。

**3.MBR分区表信息**

 <img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144305.png" alt="image-20230729185341412" />

**4.扩展分区 和 逻辑分区**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144308.png" alt="image-20230729185413069" />

gpt分区

装系统时这个分区怎么分配

### **文件系统**

**1.件系统类型**

**Linux系统支持数十种文件系统，而最常见的文件系统如下所示。**

![image-20230729185451117](https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144311.png)

**Ext2**：最早可追溯到1993年，是Linux系统的第一个商业级文件系统，它基本沿袭了UNIX文件系统的设计标准。但由于不包含日志读写功能，数据丢失的可能性很大，因此大家能不用就不用，或者顶多建议用于SD存储卡或U盘。

**Ext3**：是一款日志文件系统，它会把整个硬盘的每个写入动作的细节都预先记录下来，然后再进行实际操作，以便在发生异常宕机后能回溯追踪到被中断的部分。Ext3能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能100%地保证资料不会丢失。

**Ext4**：Ext3的改进版本，作为RHEL 6系统中默认的文件管理系统，它支持的存储容量高达1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4文件系统能够批量分配block（块），从而极大地提高了读写效率。现在很多主流服务器也会使用Ext4文件系统。

**XFS**：是一种高性能的日志文件系统，而且是RHEL 7/8中默认的文件管理系统。它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只需花费极低的计算和存储性能。它支持的最大存储容量为18EB，这几乎满足了所有需求。



<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144314.png" alt="image-20230729185459632" />

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144317.png" alt="image-20230729185509113" />

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144319.png" alt="image-20230729185515053" />



**2.VFS虚拟文件系统**

VFS（Virtual File System）系统是一种将不同文件系统统一管理的机制，它隐藏了不同文件系统的具体实现细节，使得不同的文件系统可以通过同一套API进行访问和操作。类似于windows中右键一个文件“属性”。

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144321.jpeg" alt="第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘" /><img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144325.png" alt="image-20230729185521042" />

### **挂载硬件设备**

#### **blkid命令**用于显示设备的属性信息

```
[root@linux ~]# blkid
/dev/sdb1: UUID="2db66eb4-d9c1-4522-8fab-ac074cd3ea0b" TYPE="xfs" PARTUUID="eb23857a-01"
/dev/sdb2: UUID="478fRb-1pOc-oPXv-fJOS-tTvH-KyBz-VaKwZG" TYPE="ext4" PARTUUID="eb23857a-02"
```

####  **mount用于挂载文件系统**

| 参数 | 作用                                                   |
| ---- | ------------------------------------------------------ |
| -a   | 挂载所有在/etc/fstab中定义的文件系统                   |
| -t   | 指定文件系统的类型，比如：ext4、xfs、iso9660           |
| -o   | 指定挂载选项，比如:remount、rw、ro、username、password |

例如，要把设备/dev/sdb2挂载到/backup目录，只需要在mount命令中填写设备与挂载目录参数就行，系统会自动判断要挂载文件的类型，命令如下：

```
[root@linux ~]# mount /dev/sdb2 /backup
```

如果在工作中要挂载一块网络存储设备，该设备的名字可能会变来变去，这样再写为sdb就不太合适了。这时推荐用UUID（通用唯一识别码）进行挂载操作.

blkid命令用于显示设备的属性信息,使用blkid命令来查询设备UUID的示例如下：

```
[root@linux ~]# blkid
/dev/sdb1: UUID="2db66eb4-d9c1-4522-8fab-ac074cd3ea0b" TYPE="xfs" PARTUUID="eb23857a-01"
/dev/sdb2: UUID="478fRb-1pOc-oPXv-fJOS-tTvH-KyBz-VaKwZG" TYPE="ext4" PARTUUID="eb23857a-02"
```

然后就可以通过UUID值挂载网络设备了：

```
[root@linux ~]# mount UUID=478fRb-1pOc-oPXv-fJOS-tTvH-KyBz-VaKwZG /backup
```

但是使用mount命令挂载只是临时挂载系统重启后就会失效，若要永久有效则需要写入到==/etc/fstab==文件中，该文件中只要包含6列数据，其中每列字段含义如下：

| 字段     | 意义                                                         |
| -------- | ------------------------------------------------------------ |
| 设备文件 | 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier） |
| 挂载目录 | 指定要挂载到的目录，需在挂载前创建好                         |
| 格式类型 | 指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 |
| 权限选项 | 若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async |
| 是否备份 | 若为1则开机后使用dump进行磁盘备份，为0则不备份               |
| 是否自检 | 若为1则开机后自动进行磁盘自检，为0则不自检                   |

写入到/etc/fstab文件中的设备信息并不会立即生效，需要使用mount -a参数进行自动挂载：

```
[root@linux ~]# mount -a
```

#### umount用于卸载设备或文件系统

，英文全称为“un mount”，语法格式为“umount [设备文件/挂载目录]”。

```
[root@linuxprobe ~]# umount /dev/sdb2
```

#### **df查看已挂载的磁盘占用情况**

df命令显示的磁盘使用量情况含可用、已有及使用率等信息，默认单位为Kb，建议使用-h参数进行单位换算，毕竟135M比138240Kb更利于阅读对吧

```
[root@linuxprobe~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M   18M  966M   2% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sda1             1014M  152M  863M  15% /boot
/dev/sdb2              480M   20M  460M   4% /backup
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
```

#### lsblk查看可用块设备信息

lsblk命令用于查看已挂载的磁盘的空间使用情况，如果系统中硬盘特别多，分区特别多，可以使用该命令查看

```
[root@linux ~]# lsblk 
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda             8:0    0   20G  0 disk 
├─sda1          8:1    0    1G  0 part /boot
└─sda2          8:2    0   19G  0 part 
  ├─rhel-root 253:0    0   17G  0 lvm  /
  └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]
sr0            11:0    1  6.6G  0 rom  /media/cdrom
```

### **添加硬盘设备**

#### **主分区、扩展分区和逻辑分区的区别**

(1)主分区：主分区是硬盘的启动分区，我们常说的“C盘”就是硬盘上的主分区。它被操作系统和主板认定为这个硬盘的第一个分区。所以C盘永远都是排在所有磁盘分区的第一的位置上。
(2)扩展分区：除去主分区所占用的容量以外，硬盘剩下的容量就被认定为扩展分区(也就是说：一块硬盘除去主分区外的容量后，如果对剩下的容量进行了再分区，那么，这个再分区就是扩展分区)。
(3)逻辑分区：**扩展分区是不能直接使用的**，他是以逻辑分区的方式来使用的，所以说扩展分区可以分成若干个逻辑分区。**他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分**。扩展分区如果不再进行分区了，那么整个扩展分区就是逻辑分区了。

#### fdisk磁盘分区管理

fdisk命令用于新建、修改及删除磁盘的分区表信息。

**1.fdisk命令中的参数以及作用**

| 参数 | 作用                   |
| ---- | ---------------------- |
| m    | 查看全部可用的参数     |
| n    | 添加新的分区           |
| d    | 删除某个分区信息       |
| l    | 列出所有可用的分区类型 |
| t    | 改变某个分区的类型     |
| p    | 查看分区表信息         |
| w    | 保存并退出             |
| q    | 不保存直接退出         |

**2.使用fdisk命令来尝试管理/dev/sdb硬盘设备：**

```sh
[root@linuxprobe ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.32.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.
Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x88b2c2b0.
# 1.查看分区表信息
Command (m for help): p     # 出现提示信息后输入参数p来查看硬盘设备内已有的分区信息
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x88b2c2b0

# 2.创建一个主分区
Command (m for help): n     # 参数n表示创建分区
Partition type
   p   primary (0 primary, 0 extended, 4 free)    # 参数p表示创建主分区，最多可创建4个主分区
   e   extended (container for logical partitions)# 参数3表示创建逻辑分区，分区编号默认从5开始
Select (default p): p       # 输入参数p,来创建一个主分区
Partition number (1-4, default 1):    # 设置分区编号，不填默认为1
First sector (2048-33554431, default 2048):   # 起始扇区，使用默认值即可
Last sector, +sectors or +size{K,M,G,T,P} (2048-33554431, default 33554431): +1G  # +1G，表示创建一个1G大小的主分区    
Created a new partition 1 of type 'Linux' and of size 1 GiB.   # 成功创建一个主分区

Command (m for help): p     # 输入参数p，再次查看，可以发现sdb磁盘多了一个1G的分区
Disk /dev/sdb: 16 GiB, 17179869184 bytes, 33554432 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x456105a3
Device     Boot Start     End Sectors Size Id Type
/dev/sdb1        2048 2099199 2097152   1G 83 Linux

# 3.创建一个扩展分区
Command (m for help): n  
Partition type
   # primary：主分区数, extended扩展分区数, free还可以创建几个主分区，扩展分区数会占用1个主分区数
   p   primary (1 primary, 0 extended, 3 free)   数
   e   extended (container for logical partitions)
Select (default p): e
Partition number (2-4, default 2): 
First sector (2099200-33554431, default 2099200): 
Last sector, +sectors or +size{K,M,G,T,P} (2099200-33554431, default 33554431): # 最后一个扇区默认会将剩余空间分给最后一个分区
Created a new partition 2 of type 'Extended' and of size 15 GiB.

# 4.创建逻辑分区
Command (m for help): n
All space for primary partitions is in use.
Adding logical partition 5
First sector (2101248-33554431, default 2101248): 
Last sector, +sectors or +size{K,M,G,T,P} (2101248-33554431, default 33554431): +2G
Created a new partition 5 of type 'Linux' and of size 2 GiB.

Command (m for help): p
Disk /dev/sdb: 16 GiB, 17179869184 bytes, 33554432 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x456105a3
# id表示分区类型可以使用Command (m for help):l查看都有哪些分区类型
Device     Boot   Start      End  Sectors Size Id Type       
/dev/sdb1          2048  2099199  2097152   1G 83 Linux      # 主分区
/dev/sdb2       2099200 33554431 31455232  15G  5 Extended	 # 扩展分区
/dev/sdb5       2101248  6295551  4194304   2G 83 Linux		 # 逻辑分区，需要从5开始
# 5.保存并退出
Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

#### 分区格式化

mkfs命令可以对分区进行格式化,例如将/dev/sdb1分区格式化为xfs分区类型。

```
[root@linux ~]# mkfs.xfs /dev/sdb1
meta-data=/dev/sdb1              isize=512    agcount=4, agsize=131072 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1
data     =                       bsize=4096   blocks=524288, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```



#### 分区挂载

方式一：使用mount命令挂载，系统重启后挂载会失效

```sh
[root@linux ~]# mount /dev/sdb2 /backup     # 将设备/dev/sdb2挂载到/backup
```

```sh
[root@linux ~]# mount UUID=478fRb-1pOc-oPXv-fJOS-tTvH-KyBz-VaKwZG /backup   # 通过设备uuid将设备/dev/sdb2挂载到/backup,可使用blkid命令查看设备uuid
```

方式二：写入到==/etc/fstab==文件中,重启后也能自动挂载

![image-20230824150251945](https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912144335.png)

### **添加交换分区**

在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍.

1.取出一个大小为5GB的主分区作为交换分区资源

```
[root@linux ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.32.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2): 敲击回车即可
First sector (4196352-41943039, default 4196352): 敲击回车即可
Last sector, +sectors or +size{K,M,G,T,P} (4196352-41943039, default 41943039): +5G

Created a new partition 2 of type 'Linux' and of size 5 GiB.
```

2.修改硬盘的标识码，这里将其改成82（Linux swap）

```sh
Command (m for help): t
Partition number (1,2, default 2): 2
Hex code (type L to list all codes): 82

Changed type of partition 'Linux' to 'Linux swap / Solaris'.

Command (m for help): p 
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x88b2c2b0

Device     Boot   Start      End  Sectors Size Id Type
/dev/sdb1          2048  4196351  4194304   2G 83 Linux
/dev/sdb2       4196352 14682111 10485760   5G 82 Linux swap / Solaris

Command (m for help): w   # 保存并退出
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

3.mkswap命令用于对新设备进行交换分区格式化

```sh
[root@linux ~]# mkswap /dev/sdb2
Setting up swapspace version 1, size = 5 GiB (5368705024 bytes)
no label, UUID=45a4047c-49bf-4c88-9b99-f6ac93908485
```

4.使用swapon命令把准备好的SWAP硬盘设备正式挂载到系统中

```sh
[root@linux ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1391         105          12         469         384
Swap:          2047           9        2038
[root@linux ~]# swapon /dev/sdb2
[root@linux ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1395         101          12         469         380
Swap:          7167           9        7158
```

5.向/etc/fstab写入一条配置，使其永久生效

```
/dev/sdb2                                    swap            swap       defaults    0 0 
```

### **磁盘配额**

使用quota技术进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。quota技术还有软限制和硬限制的功能。

**软限制**：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。

**硬限制**：当达到硬限制时会提示用户，且强制终止用户的操作。

1:13:48

### **VDO虚拟数据优化**

VDO（Virtual Data Optimize，虚拟数据优化）是一种通过压缩或删除存储设备上的数据来优化存储空间的技术。

对各种类型文件压缩效果汇总表

| 文件名  | 描述                            | 类型              | 原始大小（KB） | 实际占用空间（KB） |
| ------- | ------------------------------- | ----------------- | -------------- | ------------------ |
| dickens | 狄更斯文集                      | 英文原文          | 9953           | 9948               |
| mozilla | Mozilla的1.0可执行文件          | 执行程序          | 50020          | 33228              |
| mr      | 医用resonanse图像               | 图片              | 9736           | 9272               |
| nci     | 结构化的化学数据库              | 数据库            | 32767          | 10168              |
| ooffice | Open Office.org 1.01 DLL        | 可执行程序        | 6008           | 5640               |
| osdb    | 基准测试用的MySQL格式示例数据库 | 数据库            | 9849           | 9824               |
| reymont | 瓦迪斯瓦夫·雷蒙特的书           | PDF               | 6471           | 6312               |
| samba   | samba源代码                     | src源码           | 21100          | 11768              |
| sao     | 星空数据                        | 天文格式的bin文件 | 7081           | 7036               |
| webster | 辞海                            | HTML              | 40487          | 40144              |
| xml     | XML文件                         | HTML              | 5220           | 2180               |
| x-ray   | 透视医学图片                    | 医院数据          | 8275           | 8260               |

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912150234.png" alt="image-20230824192945640" />

配置VDO

1.用dnf命令即可完成安装VDO服务

```sh
[root@linux ~]# dnf install kmod-kvdo vdo
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:01:56 ago on Wed 06 Jan 2021 10:37:19 PM CST.
Package kmod-kvdo-6.2.0.293-50.el8.x86_64 is already installed.
Package vdo-6.2.0.293-10.el8.x86_64 is already installed.
Dependencies resolved.
Nothing to do.
Complete!
```

2.创建一个全新的VDO卷

```
[root@linuxprobe ~]# vdo create --name=storage --device=/dev/sdc --vdoLogicalSize=200G
Creating VDO storage
Starting VDO storage
Starting compression on VDO storage
VDO instance 0 volume is ready at /dev/mapper/storage
```

3.创建成功后，使用status参数查看新建卷的概述信息

```
[root@linux ~]# vdo status --name=storage
VDO status:
  Date: '2021-01-06 22:51:33+08:00'
  Node: linuxprobe.com
Kernel module:
  Loaded: true
  Name: kvdo
  Version information:
    kvdo version: 6.2.0.293
Configuration:
  File: /etc/vdoconf.yml
  Last modified: '2021-01-06 22:49:33'
VDOs:
  storage:
    Acknowledgement threads: 1
    Activate: enabled
    Bio rotation interval: 64
    Bio submission threads: 4
    Block map cache size: 128M
    Block map period: 16380
    Block size: 4096
    CPU-work threads: 2
    Compression: enabled
    Configured write policy: auto
    Deduplication: enabled
………………省略部分输出信息………………
```

4.新建的VDO卷设备会被放在/dev/mapper目录下,挂载前可以用udevadm settle命令对设备进行一次刷新操作，避免刚才的配置没有生效

```
[root@linux ~]# mkfs.xfs /dev/mapper/storage 
meta-data=/dev/mapper/storage    isize=512    agcount=4, agsize=13107200 blks
         =                       sectsz=4096  attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1
data     =                       bsize=4096   blocks=52428800, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=25600, version=2
         =                       sectsz=4096  sunit=1 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@linux ~]# udevadm settle
[root@linux ~]# mkdir /storage
[root@linux ~]# mount /dev/mapper/storage /storage
```

5.如果想查看设备的实际使用情况，使用vdostats命令即可。human-readable参数的作用是将存储容量自动进位，以人们更易读的方式输出（比如，显示20G而不是20971520K）：

```
[root@linux ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.0G     16.0G  20%           99%
```

6.这里显示的Size是实际物理存储的空间大小（即20.0GB是硬盘的大小），如果想看逻辑存储空间，可以使用df命令进行查看：

```
[root@linux ~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M  9.6M  974M   1% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
/dev/sda1             1014M  152M  863M  15% /boot
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/sdb1              2.0G   47M  2.0G   3% /newFS
/dev/mapper/storage    200G  2.4G  198G   2% /storage
```

7.随便复制一个大文件过来，看看占用了多少容量，以及空间节省率（Space saving）是多少：

```
[root@linuxprobe ~]# ls -lh /media/cdrom/images/install.img 
-r--r--r--. 1 root root 448M Apr 4 2019 /media/cdrom/images/install.img
[root@linuxprobe ~]# cp /media/cdrom/images/install.img /storage/
[root@linuxprobe ~]# ls -lh /storage/install.img 
-r--r--r--. 1 root root 448M Jan  6 23:06 /storage/install.img
[root@linuxprobe ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.4G     15.6G  22%           18%
```

8.效果不明显，再复制一份相同的文件过来，看看这次占用了多少空间：

```
[root@linuxprobe ~]# cp /media/cdrom/images/install.img /storage/rhel.img
[root@linuxprobe ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.5G     15.5G  22%           55%
```

9.将设备设置成永久挂载生效

```
[root@linuxprobe ~]# blkid /dev/mapper/storage 
/dev/mapper/storage: UUID="cd4e9f12-e16a-415c-ae76-8de069076713" TYPE="xfs"
```

10.打开/etc/fstab文件，把对应的字段填写完整。建议再加上_netdev参数，表示等系统及网络都启动后再挂载VDO设备卷,否则系统重启后，将无法正常进入系统

```
UUID=cd4e9f12-e16a-415c-ae76-8de069076713    /storage      xfs        defaults,_netdev   0 0 
```

###  **软连接和硬链接**

**软链接（soft link）：**也叫符号链接（symbolic link），仅仅包含所链接文件的名称和路径，很像一个记录地址的标签。当原始文件被删除或移动后，新的链接文件也会随之失效，不能被访问。可以针对文件、目录设置软链接，跨文件系统进行链接也不是问题。从这一点来看，它与Windows系统的“快捷方式”具有一样的性质。用户访问软链接的效果如图6-15所示。

**硬链接（hard link）：**可以将它理解为一个“指向原始文件block的指针”，系统会创建出一个与原来一模一样的inode信息块。所以，硬链接文件与原始文件其实是一模一样的，只是名字不同。每添加一个硬链接，该文件的inode个数就会增加1；而且只有当该文件的inode个数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件block的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，不能跨分区对目录文件进行硬链接。用户访问硬链接的效果如图6-16所示。

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912150324.png" alt="image-20230729190354021" />

## 使用RAID与LVM磁盘阵列技术

![image-20230730193754271](https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912150543.png)

### RAID磁盘阵列

**mdadm命令**

| 参数 | 作用             |
| ---- | ---------------- |
| -a   | 检测设备名称     |
| -n   | 指定设备数量     |
| -l   | 指定RAID级别     |
| -C   | 创建             |
| -v   | 显示过程         |
| -f   | 模拟设备损坏     |
| -r   | 移除设备         |
| -Q   | 查看摘要信息     |
| -D   | 查看详细信息     |
| -S   | 停止RAID磁盘阵列 |

**使用mdadm命令创建RAID 10**

```
[root@linux ~]# mdadm -Cv /dev/md0 -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde
mdadm: layout defaults to n2
mdadm: layout defaults to n2
mdadm: chunk size defaults to 512K
mdadm: size set to 20954112K
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
```

初始化过程大约需要1分钟左右，期间可以用-D参数进行查看。也可以用-Q参数查看简要信息：

```
[root@linux ~]# mdadm -Q /dev/md0
/dev/md0: 39.97GiB raid10 4 devices, 0 spares. Use mdadm --detail for more detail.
```

#### **部署磁盘阵列**

#### **删除磁盘阵列**

#### RAID故障模拟和修复

#### 给RAID添加热备盘

### LVM逻辑卷管理

**1.LVM的核心理念**

LVM是Linux系统用于对硬盘分区进行管理的一种机制，理论性较强，其创建初衷是为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。在日常的使用中，如果卷组（VG）的剩余容量不足，可以随时将新的物理卷（PV）加入到里面，进行不断地扩容。物理卷处于LVM中的最底层，可以将其理解为物理硬盘、硬盘分区或者RAID磁盘阵列。卷组建立在物理卷之上，一个卷组能够包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。这就是LVM的核心理念。

**2.逻辑卷管理器使用流程图及常用部署命令**

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912151250.png" alt="image-20230825143825682" />


#### **部署逻辑卷**

1.新添加的两块硬盘设备支持LVM技术。

```
[root@linuxprobe ~]# pvcreate /dev/sdb /dev/sdc
  Physical volume "/dev/sdb" successfully created.
  Physical volume "/dev/sdc" successfully created.
```

2.把两块硬盘设备加入到storage卷组中，然后查看卷组的状态。

```
[root@linuxprobe ~]# vgcreate storage /dev/sdb /dev/sdc
 Volume group "storage" successfully created
[root@linuxprobe ~]# vgdisplay
  --- Volume group ---
  VG Name               storage
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               39.99 GiB
  PE Size               4.00 MiB
  Total PE              10238
  Alloc PE / Size       0 / 0   
  Free  PE / Size       10238 / 39.99 GiB
  VG UUID               HPwsm4-lOvI-8O0Q-TG54-BkyI-ONYE-owlGLd
………………省略部分输出信息………………
```

**第3步**：再切割出一个约为150MB的逻辑卷设备。

在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷。另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。

例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。

```
[root@linuxprobe ~]# lvcreate -n vo -l 37 storage
 Logical volume "vo" created.
[root@linuxprobe ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/storage/vo
  LV Name                vo
  VG Name                storage
  LV UUID                AsDGJj-G6Uo-HG4q-auD6-lmyn-aLY0-o36HEj
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2021-01-15 00:47:35 +0800
  LV Status              available
  # open                 0
  LV Size                148.00 MiB
  Current LE             37
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:2
………………省略部分输出信息………………
```

4.把生成好的逻辑卷进行格式化，然后挂载使用

```
[root@linuxprobe ~]# mkfs.dext4 /dev/storage/vo 
mke2fs 1.44.3 (10-July-2018)
Creating filesystem with 151552 1k blocks and 38000 inodes
Filesystem UUID: 429cbc28-4463-4a1b-b601-02a7cf81a1b2
Superblock backups stored on blocks: 
	8193, 24577, 40961, 57345, 73729

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done 
[root@linuxprobe ~]# mkdir /linuxprobe
[root@linuxprobe ~]# mount /dev/storage/vo /linuxprobe
```

5.查看挂载状态，并写入配置文件，使其永久生效。

```
[root@linuxprobe ~]# df -h
Filesystem              Size  Used Avail Use% Mounted on
devtmpfs                969M     0  969M   0% /dev
tmpfs                   984M     0  984M   0% /dev/shm
tmpfs                   984M  9.6M  974M   1% /run
tmpfs                   984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root    17G  3.9G   14G  23% /
/dev/sr0                6.7G  6.7G     0 100% /media/cdrom
/dev/sda1              1014M  152M  863M  15% /boot
tmpfs                   197M   16K  197M   1% /run/user/42
tmpfs                   197M  3.4M  194M   2% /run/user/0
/dev/mapper/storage-vo  140M  1.6M  128M   2% /linuxprobe
[root@linuxprobe ~]# echo "/dev/storage/vo /linuxprobe ext4 defaults 0 0" >> /etc/fstab
[root@linuxprobe ~]# cat /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                       /                       xfs      defaults        0 0
UUID=2db66eb4-d9c1-4522-8fab-ac074cd3ea0b   /boot                   xfs      defaults        0 0
/dev/mapper/rhel-swap                       swap                    swap     defaults        0 0
/dev/cdrom                                  /media/cdrom            iso9660  defaults        0 0 
/dev/storage/vo                             /linuxprobe             ext4     defaults        0 0
```



#### **扩容逻辑卷**



#### **缩小逻辑卷**



如果逻辑卷有数据缩小会丢数据嘛

#### **逻辑卷快照**



#### **删除逻辑卷**

## 使用iptables与Firewalld防火墙

### **防火墙管理工具**

### **IPtables**

#### **策略与规则链**

#### **iptables的基本命令**

### **Firewalld**

#### **终端管理工具**

#### **图形管理工具**

### **Cockpit管理工具**

## 使用ssh服务管理远程主机

### **配置网卡服务**

#### **配置网卡参数**

#### **创建网络连接 配置文件**

#### **网卡绑定**

### **远程控制服务**

**常见远程控制工具：**

​		**Windows:**Xshell、Mobaxterm、Putty、一些windows自带ssh工具

​		**Linux:**openssh-clients等

​		**==推荐：==**FinalShell（支持Windows、Linux、macOS）

#### **配置sshd服务**

**1.SSH**（Secure [Shell](https://www.linuxcool.com/)）是一种能够以安全的方式提供远程登录的协议，也是目前远程管理Linux系统的首选方式。想要使用SSH协议来远程管理Linux系统，则需要配置部署sshd服务程序。sshd是基于SSH协议开发的一款远程管理服务程序,sshd提供两种安全验证的方法：

> **基于密码的验证**—用账户和密码来验证登录；
>
> **基于密钥的验证**—需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较；该方式相较来说更安全。

**2.sshd服务配置文件中包含的参数以及作用**

| 参数                              | 作用                                |
| --------------------------------- | ----------------------------------- |
| Port 22                           | 默认的sshd服务端口                  |
| ListenAddress 0.0.0.0             | 设定sshd服务器监听的IP地址          |
| Protocol 2                        | SSH协议的版本号                     |
| HostKey /tc/ssh/ssh_host_key      | SSH协议版本为1时，DES私钥存放的位置 |
| HostKey /etc/ssh/ssh_host_rsa_key | SSH协议版本为2时，RSA私钥存放的位置 |
| HostKey /etc/ssh/ssh_host_dsa_key | SSH协议版本为2时，DSA私钥存放的位置 |
| PermitRootLogin yes               | 设定是否允许root管理员直接登录      |
| StrictModes yes                   | 当远程用户的私钥改变时直接拒绝连接  |
| MaxAuthTries 6                    | 最大密码尝试次数                    |
| MaxSessions 10                    | 最大终端数                          |
| PasswordAuthentication yes        | 是否允许密码验证                    |
| PermitEmptyPasswords no           | 是否允许空密码登录（很不安全）      |

**3.sshd配置文件**

```sh
[root@Server ~]# vim /etc/ssh/sshd_config 
 ………………省略部分输出信息………………
 43 # Authentication:
 44 
 45 #LoginGraceTime 2m
 46 PermitRootLogin no
 47 #StrictModes yes
 48 #MaxAuthTries 6
 49 #MaxSessions 10
 ………………省略部分输出信息………………
# 文件修改需要执行以下命令让文件生效，最好也将这个服务程序加入到开机启动项中。
[root@Server ~]# systemctl restart sshd
[root@Server ~]# systemctl enable sshd
```

**4.链接方式**

使用两台虚拟机，一台充当服务器，另外一台充当客户端:

| 主机地址      | 操作系统 | 作用   |
| ------------- | -------- | ------ |
| 192.168.10.10 | Linux    | 服务器 |
| 192.168.10.20 | Linux    | 客户端 |

在客户端中链接服务端：

```
[root@Client ~]# ssh root@192.168.10.10
The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.
ECDSA key fingerprint is SHA256:5d52kZi1la/FJK4v4jibLBZhLqzGqbJAskZiME6ZXpQ.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.
root@192.168.10.10's password: 此处输入服务器管理员密码
Activate the web console with: systemctl enable --now cockpit.socket

Last login: Fri Jul 24 06:26:58 2020
[root@Server ~]# 
[root@Server ~]# exit
logout
Connection to 192.168.10.10 closed.
```

#### **安全密钥验证**

**ssh免密登录**

1.在客户端主机中生成“密钥对”。

```sh
[root@Client ~]# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 按回车键或设置密钥的存储路径
Enter passphrase (empty for no passphrase): 直接按回车键或设置密钥的密码
Enter same passphrase again: 再次按回车键或设置密钥的密码
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:kHa7B8V0nk63evABRrfZhxUpLM5Hx0I6gb7isNG9Hkg root@linuxprobe.com
The key's randomart image is:
+---[RSA 2048]----+
|          o.=.o.+|
|       . + =oB X |
|      + o =oO O o|
|     . o + *.+ ..|
|      .ES . + o  |
|     o.o.=   + . |
|      =.o.o . o  |
|     . . o.  .   |
|        ..       |
+----[SHA256]-----+
```

2.把客户端主机中生成的公钥文件传送至远程服务器。

```sh
[root@Client ~]# ssh-copy-id 192.168.10.10
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.10.10's password: 此处输入服务器管理员密码

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh '192.168.10.10'"
and check to make sure that only the key(s) you wanted were added.
```

3.对服务器进行设置，使其只允许密钥验证，拒绝传统的密码验证方式。记得在修改配置文件后保存并重启sshd服务程序。

```
[root@Server ~]# vim /etc/ssh/sshd_config 
 ………………省略部分输出信息………………
 70 # To disable tunneled clear text passwords, change to no here!
 71 #PasswordAuthentication yes
 72 #PermitEmptyPasswords no
 73 PasswordAuthentication no
 74 
 ………………省略部分输出信息………………
[root@Server ~]# systemctl restart sshd
```

4.户端尝试登录到服务器。

```
[root@Client ~]# ssh root@192.168.10.10
Activate the web console with: systemctl enable --now cockpit.socket

Last failed login: Thu Jan 28 13:44:09 CST 2021 from 192.168.10.20 on ssh:notty
There were 2 failed login attempts since the last successful login.
Last login: Thu Jan 28 13:22:34 2021 from 192.168.10.20
```

#### **远程传输命令**

### **不间断会话服务**

#### **管理远程会话**

#### **管理多窗格**

#### **会话共享功能**

### **检索日志信息**

## 使用Ansible服务实现自动化运维

### **Ansible介绍与安装**

**Ansible简介**

Ansible目前是运维自动化工具中最简单、容易上手的一款优秀软件，能够用来管理各种资源。用户可以使用Ansible自动部署应用程序，以此实现IT基础架构的全面部署。例如，借助于Ansible，我们可以轻松地对服务器进行初始化配置、安全基线配置，以及进行更新和打补丁操作。

**Ansible服务专用术语对照表**

| 术语          | 中文叫法 | 含义                                                         |
| ------------- | -------- | ------------------------------------------------------------ |
| Control node  | 控制节点 | 指的是安装了Ansible服务的主机，也被称为Ansible控制端，主要是用来发布运行任务、调用功能模块，对其他主机进行批量控制。 |
| Managed nodes | 受控节点 | 指的是被Ansible服务所管理的主机，也被称为受控主机或客户端，是模块[命令](https://www.linuxcool.com/)的被执行对象。 |
| Inventory     | 主机清单 | 指的是受控节点的列表，可以是IP地址、主机名称或者域名。       |
| Modules       | 模块     | 指的是上文提到的特定功能代码，默认自带有上千款功能模块，在Ansible Galaxy有超多可供选择。 |
| Task          | 任务     | 指的是Ansible客户端上面要被执行的操作。                      |
| Playbook      | 剧本     | 指的是通过YAML语言编写的可重复执行的任务列表，把常做的操作写入到剧本文件中，下次可以直接重复执行一遍。 |
| Roles         | 角色     | 从Ansible 1.2版本开始引入的新特性，用于结构化的组织Playbook，通过调用角色实现一连串的功能。 |

**安装**

```
[root@linuxprobe ~]# dnf install -y ansible
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:01:31 ago on Sun 04 Apr 2021 02:23:32 AM CST.
Dependencies resolved.
………………省略部分输出信息…………
# 检查
[root@linuxprobe ~]# ansible --version
ansible 2.9.18
  config file = /etc/ansible/ansible.cfg
  configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python3.6/site-packages/ansible
  executable location = /usr/bin/ansible
  python version = 3.6.8 (default, Jan 11 2019, 02:17:16) [GCC 8.2.1 20180905 (Red Hat 8.2.1-3)]
```

### **设置主机清单**

在初次使用Ansible服务时，大家可能会遇到这种情况：参数明明已经修改了，但却不生效。这是因为Ansible服务的主配置文件存在优先级的顺序关系，默认存放在/etc/ansible目录中的主配置文件优先级最低。如果在当前目录或用户家目录中也存放着一份主配置文件，则以当前目录或用户家目录中的主配置文件为主。

#### **Ansible服务主配置文件优先级顺序**

| 优先级 | 文件位置                 |
| ------ | ------------------------ |
| 高     | ./ansible.cfg            |
| 中     | ~/.ansible.cfg           |
| 低     | /etc/ansible/ansible.cfg |

#### **主机清单**

Ansible服务是用于实现主机批量自动化控制的管理工具，受管的主机一定不是一两台台，而是数十台甚至成百上千台，那么主机清单（inventory）在生产环境中就可以帮上大忙了。用户可以把要管理的主机IP地址预先写入**/etc/ansible/hosts**文件，这样后续再通过执行ansible命令来执行任务时就自动包含这些主机了，也就不需要每次都重复输入受管主机的地址了。

#### **受管主机信息**

| 操作系统 | IP地址        | 功能用途  |
| -------- | ------------- | --------- |
| RHEL 8   | 192.168.10.20 | dev       |
| RHEL 8   | 192.168.10.21 | test      |
| RHEL 8   | 192.168.10.22 | prod      |
| RHEL 8   | 192.168.10.23 | prod      |
| RHEL 8   | 192.168.10.24 | balancers |

模拟产环境中的常见需求，我们又为这5台主机分别规划了功能用途，有开发机（dev）、测试机（test）、产品机（prod）（两台）和负载均衡机（balancers）。在对主机进行分组标注。

```
[root@linux ~]# vim /etc/ansible/hosts
[dev]
192.168.10.20
[test]
192.168.10.21
[prod]
192.168.10.22
192.168.10.23
[balancers]
192.168.10.24
```

结构化的方式显示出受管主机的信息，可是使用“ansible-inventory --graph”命来查看。

```
[root@linux ~]# ansible-inventory --graph
@all:
  |--@balancers:
  |  |--192.168.10.24
  |--@dev:
  |  |--192.168.10.20
  |--@prod:
  |  |--192.168.10.22
  |  |--192.168.10.23
  |--@test:
  |  |--192.168.10.21
  |--@ungrouped:
```

#### **Ansible常用变量汇总**

| 参数                                             | 作用          |
| ------------------------------------------------ | ------------- |
| ansible_ssh_host                                 | 受管主机名    |
| ansible_ssh_port                                 | 端口号        |
| ansible_ssh_user                                 | 默认账号      |
| ansible_ssh_pass                                 | 默认密码      |
| ansible_[shell](https://www.linuxcool.com/)_type | Shell终端类型 |

#### 必要配置

Ansible服务是基于SSH协议进行自动化控制的，需要将对应的变量及信息填写到主机清单文件中，在执行任务时便会自动对账号和密码进行匹配，而不用每次重复输入它们。

```
[root@linux ~]# vim /etc/ansible/hosts
[dev]
192.168.10.20
[test]
192.168.10.21
[prod]
192.168.10.22
192.168.10.23
[balancers]
192.168.10.24
[all:vars]
ansible_user=root
ansible_password=redhat

# 修改主配置文件，使其不需要SSH协议的指纹验证，默认执行脚本时用root权限执行
vim /etc/ansible/ansible.cfg
[root@linuxprobe ~]# vim /etc/ansible/ansible.cfg
69
70 # uncomment this to disable SSH key host checking
71 host_key_checking = False
72
………………省略部分输出信息………………
104
105 # default user to use for playbooks if user is not specified
106 # (/usr/bin/ansible will use current user as default)
107 remote_user = root
108
```

### **运行临时命令**

Ansible服务的强大之处在于只需要一条命令，便可以操控成千上万台的主机节点，而ansible命令便是最得力的工具之一。

#### **Ansible服务常用模块名称及作用**

| 模块名称       | 模块作用                                 |
| -------------- | ---------------------------------------- |
| ping           | 检查受管节点主机网络是否能够联通。       |
| yum            | 安装、更新及卸载软件包。                 |
| yum_repository | 管理主机的软件仓库配置文件。             |
| template       | 复制模板文件到受管节点主机。             |
| copy           | 新建、修改及复制文件。                   |
| user           | 创建、修改及删除用户。                   |
| group          | 创建、修改及删除用户组。                 |
| service        | 启动、关闭及查看服务状态。               |
| get_url        | 从网络中下载文件。                       |
| file           | 设置文件权限及创建快捷方式。             |
| cron           | 添加、修改及删除计划任务。               |
| command        | 直接执行用户指定的命令。                 |
| shell          | 直接执行用户指定的命令（支持特殊字符）。 |
| debug          | 输出调试或报错信息。                     |
| mount          | 挂载硬盘设备文件。                       |
| filesystem     | 格式化硬盘设备文件。                     |
| lineinfile     | 通过正则表达式修改文件内容。             |
| setup          | 收集受管节点主机上的系统及变量信息。     |
| firewalld      | 添加、修改及删除防火墙策略。             |
| lvg            | 管理主机的物理卷及卷组设备。             |
| lvol           | 管理主机的逻辑卷设备。                   |

ansible命令常用的语法格式为“ansible受管主机节点 -m模块名称[-a模块参数]”

#### **ansible命令常用参数**

| 参数      | 作用                    |
| --------- | ----------------------- |
| -k        | 手动输入SSH协议密码     |
| -i        | 指定主机清单文件        |
| -m        | 指定要使用的模块名      |
| -M        | 指定要使用的模块路径    |
| -S        | 使用su命令              |
| -T        | 设置SSH协议连接超时时间 |
| -a        | 设置传递给模块的参数    |
| --version | 查看版本信息            |
| -h        | 帮助信息                |

#### ansible-doc命令

进行查找模块具体的作用

```
[root@linuxprobe ~]# ansible-doc -l 
a10_server                                           Manage A10 Networks AX/SoftAX/Thunder/v...
a10_server_axapi3                                    Manage A10 Networks AX/SoftAX/Thunder/v...           
a10_service_group                                    Manage A10 Networks AX/SoftAX/Thunder/v...
a10_virtual_server                                   Manage A10 Networks AX/SoftAX/Thunder/v...
aci_aaa_user                                         Manage AAA users (aaa:User)                                              
aci_aaa_user_certificate                             Manage AAA user certificates (aaa:User...                        
aci_access_port_block_to_access_port                 Manage port blocks of Fabric interface ...
aci_access_port_to_interface_policy_leaf_profile     Manage Fabric interface policy leaf pro...
aci_access_sub_port_block_to_access_port             Manage sub port blocks of Fabric interf...
aci_aep                                              Manage attachable Access Entity Profile...
aci_aep_to_domain                                    Bind AEPs to Physical or Virtual Domain...   
aci_bd_subnet                                        Manage Subnets (fv:Subnet)                 
………………省略部分输出信息………………
```

#### 查看主机是否在线

```
[root@linuxprobe ~]# ansible all -m ping
192.168.10.20 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
192.168.10.21 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
192.168.10.22 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
192.168.10.23 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}192.168.10.24 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
```

#### 管理主机的软件仓库

**参考模板**

```
[root@linuxprobe ~]# ansible-doc yum_repository
……………………省略部分输出信息………………
EXAMPLES:

- name: Add repository
  yum_repository:
    name: epel
    description: EPEL YUM repo
    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/

- name: Add multiple repositories into the same file (1/2)
  yum_repository:
    name: epel
    description: EPEL YUM repo
    file: external_repos
    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/
    gpgcheck: no

- name: Add multiple repositories into the same file (2/2)
  yum_repository:
    name: rpmforge
    description: RPMforge YUM repo
    file: external_repos
    baseurl: http://apt.sw.be/redhat/el7/en/$basearch/rpmforge
```

**示例：**

新增软件仓库信息

| 仓库名称    | EX294_BASE                                     |
| ----------- | ---------------------------------------------- |
| 仓库描述    | EX294 base software                            |
| 仓库地址    | file:///media/cdrom/BaseOS                     |
| GPG签名     | 启用                                           |
| GPG密钥文件 | file:///media/cdrom/RPM-GPG-KEY-redhat-release |

对照着EXAMPLE实例段，逐一对应填写需求值和参数，其标准格式是在-a参数后接整体参数（用单引号圈起），而各个参数字段的值则用双引号圈起。

```
[root@linux ~]# ansible all -m yum_repository -a 'name="EX294_BASE" description="EX294 base software" baseurl="file:///media/cdrom/BaseOS" gpgcheck=yes enabled=1 gpgkey="file:///media/cdrom/RPM-GPG-KEY-redhat-release"'

192.168.10.20 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": true,
    "repo": "EX294_BASE",
    "state": "present"
}
```

命令执行成功后，可以到主机清单中的任意机器上查看新建成功的软件仓库配置文件。

```
[root@linuxprobe ~]# cat /etc/yum.repos.d/EX294_BASE.repo 
[EX294_BASE]
baseurl = file:///media/cdrom/BaseOS
enabled = 1
gpgcheck = 1
gpgkey = file:///media/cdrom/RPM-GPG-KEY-redhat-release
name = EX294 base software
```

### **剧本文件实战**

Ansible服务的剧本（playbook）文件采用YAML语言编写，具有强制性的格式规范，它通过空格将不同信息分组，因此有时会因一两个空格错位而导致报错。大家在使用时要万分小心。YAML文件的开头需要先写3个减号（---），多个分组的信息需要间隔一致才能执行，而且上下也要对齐，后缀名一般为.yml。剧本文件在执行后，会在屏幕上输出运行界面，内容会根据工作的不同而变化。在运行界面中，绿色表示成功，黄色表示执行成功并进行了修改，而红色则表示执行失败。

剧本文件的结构由4部分组成，分别是target、variable、task、handler，其各自的作用如下。

> **target**：用于定义要执行剧本的主机范围。
>
> **variable**：用于定义剧本执行时要用到的变量。
>
> **task**：用于定义将在远程主机上执行的任务列表。
>
> **handler**：用于定义执行完成后需要调用的后续任务。

一个剧本正确的写法：

```
[root@linux ~]# vim packages.yml
---
- name: 安装软件包
  hosts: dev,test,prod
  tasks:
          - name: one
            yum:
                    name: mariadb
                    state: latest
                    

```

```
[root@linux ~]# ansible-playbook packages.yml 
PLAY [安装软件包] *******************************************************************
TASK [Gathering Facts] **************************************************************
ok: [192.168.10.20]
ok: [192.168.10.21]
ok: [192.168.10.22]
ok: [192.168.10.23]
TASK [one] **************************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]
PLAY RECAP **************************************************************************
192.168.10.20  : ok=2   changed=1  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.21  : ok=2   changed=1  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.22  : ok=2   changed=1  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.23  : ok=2   changed=1  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0 
```

### **创建及使用角色**

Ansible服务的角色功能类似于编程中的封装技术—将具体的功能封装起来，用户不仅可以方便地调用它，而且甚至可以不用完全理解其中的原理。角色的获取有3种方法，分别是加载系统内置角色、从外部环境获取角色以及自行创建角色。

#### **加载系统内置角色**

安装包含系统角色的软件包rhel-system-roles

```
[root@linux ~]# dnf install -y rhel-system-roles
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 1:06:26 ago on Tue 13 Apr 2021 07:22:03 AM CST.
Dependencies resolved.
================================================================================
 Package                  Arch          Version          Repository        Size
================================================================================
Installing:
 rhel-system-roles        noarch        1.0-5.el8        AppStream        127 k

Transaction Summary
================================================================================
Install  1 Package

………………省略部分输出信息………………  

Installed:
  rhel-system-roles-1.0-5.el8.noarch                             
Complete!
```

使用ansible-galaxy list命令查看RHEL 8系统中有哪些自带的角色可用：

```
[root@linuxprobe ~]# ansible-galaxy list
# /usr/share/ansible/roles
- linux-system-roles.kdump, (unknown version)
- linux-system-roles.network, (unknown version)
- linux-system-roles.postfix, (unknown version)
- linux-system-roles.selinux, (unknown version)
- linux-system-roles.timesync, (unknown version)
- rhel-system-roles.kdump, (unknown version)
- rhel-system-roles.network, (unknown version)
- rhel-system-roles.postfix, (unknown version)
- rhel-system-roles.selinux, (unknown version)
- rhel-system-roles.timesync, (unknown version)
# /etc/ansible/roles
[WARNING]: - the configured path /root/.ansible/roles does not exist.
```

ansible系统角色描述

| 角色名称                   | 作用                  |
| -------------------------- | --------------------- |
| rhel-system-roles.kdump    | 配置kdump崩溃恢复服务 |
| rhel-system-roles.network  | 配置网络接口          |
| rhel-system-roles.selinux  | 配置SELinux策略及模式 |
| rhel-system-roles.timesync | 配置网络时间协议      |
| rhel-system-roles.postfix  | 配置邮件传输服务      |
| rhel-system-roles.firewall | 配置防火墙服务        |
| rhel-system-roles.tuned    | 配置系统调优选项      |

以rhel-system-roles.timesync角色为例，它用于设置系统的时间和NTP服务，让主机能够同步准确的时间信息。剧本模板文件存放在/usr/share/doc/rhel-system-roles/目录中，可以复制过来修改使用：

```
[root@linuxprobe ~]# cp /usr/share/doc/rhel-system-roles/timesync/example-timesync-playbook.yml timesync.yml
```

NTP服务器主要用于同步计算机的时间，可以提供高精度的时间校准服务，帮助计算机校对系统时钟。在复制来的剧本模板文件中，删除掉多余的代码，将NTP服务器的地址填写到timesync_ntp_servers变量的hostname字段中即可。

timesync_ntp_servers变量参数含义

| 参数     | 作用            |
| -------- | --------------- |
| hostname | NTP服务器主机名 |
| iburst   | 启用快速同步    |

```
[root@linuxprobe ~]# vim timesync.yml 
---
- hosts: all
  vars:
    timesync_ntp_servers:
      - hostname: pool.ntp.org
        iburst: yes
  roles:
    - rhel-system-roles.timesync
```

#### **从外部获取角色**

从Ansible Galaxy中获取的角色，Ansible Galaxy是Ansible的一个官方社区，用于共享角色和功能代码，用户可以在网站自由地共享和下载Ansible角色。

#### **创建新的角色**

接下来将会创建一个名为apache的新角色，它能够帮助我们自动安装、运行httpd网站服务，设置防火墙的允许规则，以及根据每个主机生成独立的index.html首页文件。

在Ansible的主配置文件中，第68行定义的是角色保存路径。如果用户新建的角色信息不在规定的目录内，则无法使用ansible-galaxy list命令找到。因此需要手动填写新角色的目录路径，或是进入/etc/ansible/roles目录内再进行创建。为了避免后期角色信息过于分散导致不好管理，我们还是决定在默认目录下进行创建，不再修改。

```
[root@linuxe roles]# vim /etc/ansible/ansible.cfg
 66 
 67 # additional paths to search for roles in, colon separated
 68 #roles_path    = /etc/ansible/roles
 69 
```

在ansible-galaxy命令后面跟一个init参数，创建一个新的角色信息，且建立成功后便会在当前目录下生成出一个新的目录：

```
[root@linuxe ~]# cd /etc/ansible/roles
[root@linuxe roles]# ansible-galaxy init apache
- Role apache was created successfully
[root@linuxe roles]# ls
apache nginx nginxinc.nginx
```

此时的apache即是角色名称，也是用于存在角色信息的目录名称。切换到该目录下，查看它的结构：

```
[root@linuxe roles]# cd apache
[root@linuxe apache]# ls
defaults  files  handlers  meta  README.md  tasks  templates  tests  vars
```

在创建新角色时，最关键的便是能够正确理解目录结构。通俗来说，就是要把正确的信息放入正确的目录中，这样在调用角色时才能有正确的效果。

**Ansible角色目录结构及含义**

| 目录      | 含义                                           |
| --------- | ---------------------------------------------- |
| defaults  | 包含角色变量的默认值（优先级低）。             |
| files     | 包含角色执行tasks任务时做引用的静态文件。      |
| handlers  | 包含角色的处理程序定义。                       |
| meta      | 包含角色的作者、许可证、频台和依赖关系等信息。 |
| tasks     | 包含角色所执行的任务。                         |
| templates | 包含角色任务所使用的Jinja2模板。               |
| tests     | 包含用于测试角色的剧本文件。                   |
| vars      | 包含角色变量的默认值（优先级高）。             |

**下面准备创建新角色**

**第1步**：打开用于定义角色任务的tasks/main.yml文件。在该文件中不需要定义要执行的主机组列表，因为后面会单独编写剧本进行调用，此时应先对apache角色能做的事情（任务）有一个明确的思路，在调用角色后yml文件会按照从上到下的顺序自动执行。

> **任务1**：安装httpd网站服务。
>
> **任务2**：运行httpd网站服务，并加入到开机启动项中。
>
> **任务3**：配置防火墙，使其放行HTTP协议。
>
> **任务4**：根据每台主机的变量值，生成不同的主页文件。

先写出第一个任务。使用yum模块安装httpd网站服务程序（注意格式）：

```
[root@linuxprobe apache]# vim tasks/main.yml
---
- name: one
  yum:
          name: httpd
          state: latest
```

第2步：使用service模块启动httpd网站服务程序，并加入到启动项中，保证能够一直为用户提供服务。在初次使用模块前，先用ansible-doc命令查看一下帮助和实例信息。由于篇幅的限制，这里对信息进行了删减，仅保留了有用的内容。

```
[root@linuxprobe apache]# ansible-doc service
> SERVICE    (/usr/lib/python3.6/site-packages/ansible/modules/system/service.py)

        Controls services on remote hosts. Supported init systems
        include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.
        For Windows targets, use the [win_service] module instead.

  * This module is maintained by The Ansible Core Team
  * note: This module has a corresponding action plugin.

………………省略部分输出信息………………

EXAMPLES:

- name: Start service httpd, if not started
  service:
    name: httpd
    state: started

- name: Enable service httpd, and not touch the state
  service:
    name: httpd
    enabled: yes
```

默认的EXAMPLES示例使用的就是httpd网站服务。通过输出信息可得知，启动服务为“state: started”参数，而加入到开机启动项则是“enabled: yes”参数。

```
[root@linuxprobe apache]# vim tasks/main.yml
---
- name: one
  yum:
          name: httpd
          state: latest
- name: two
  service:
          name: httpd
          state: started
          enabled: yes
```

第3步：配置防火墙的允许策略，让其他主机可以正常访问。在配置防火墙时，需要使用firewalld模块。同样也是先看一下帮助示例：

```
[root@linuxprobe defaults]# ansible-doc firewalld
> FIREWALLD    (/usr/lib/python3.6/site-packages/ansible/modules/system/firewalld.py)

        This module allows for addition or deletion of services and
        ports (either TCP or UDP) in either running or permanent
        firewalld rules.

  * This module is maintained by The Ansible Community
OPTIONS (= is mandatory):
EXAMPLES:

- firewalld:
    service: https
    permanent: yes
    state: enabled

- firewalld:
    port: 8081/tcp
    permanent: yes
    state: disabled
    immediate: yes
```

依据输出信息可得知，在firewalld模块设置防火墙策略时，指定协议名称为“service: http”参数，放行该协议为“state: enabled”参数，设置为永久生效为“permanent: yes”参数，当前立即生效为“immediate: yes”参数。参数虽然多了一些，但是基本与在第8章节学习的一致，并不需要担心。

```
[root@linuxprobe apache]# vim tasks/main.yml
---
- name: one
  yum:
          name: httpd
          state: latest
- name: two
  service:
          name: httpd
          state: started
          enabled: yes
- name: three
  firewalld:
          service: http
          permanent: yes
          state: enabled
          immediate: yes
```

第4步：让每台主机显示的主页文件均不相同。在使用Ansible的常规模块时，都是采用“查询版主示例并模仿”的方式搞定的，这里为了增加难度，我们再提出个新需求，即能否让每台主机上运行的httpd网站服务都能显示不同的内容呢？例如显示当前服务器的主机名及IP地址。这就要用到template模块及Jinja2技术了。

使用ansible-doc命令来查询template模块的使用方法。

```
[root@linuxprobe apache]# ansible-doc template
> TEMPLATE    (/usr/lib/python3.6/site-packages/ansible/modules/files/template.>

        Templates are processed by the L(Jinja2 templating
        language,http://jinja.pocoo.org/docs/). Documentation on the
        template formatting can be found in the L(Template Designer
        Documentation,http://jinja.pocoo.org/docs/templates/).
        Additional variables listed below can be used in templates.
        `ansible_managed' (configurable via the `defaults' section of
        `ansible.cfg') contains a string which can be used to describe
        the template name, host, modification time of the template
        file and the owner uid. `template_host' contains the node name
        of the template's machine. `template_uid' is the numeric user
        id of the owner. `template_path' is the path of the template.
        `template_fullpath' is the absolute path of the template.
        `template_destpath' is the path of the template on the remote
        system (added in 2.8). `template_run_date' is the date that
        the template was rendered.

  * This module is maintained by The Ansible Core Team
  * note: This module has a corresponding action plugin.

………………省略部分输出信息………………

EXAMPLES:

- name: Template a file to /etc/files.conf
  template:
    src: /mytemplates/foo.j2
    dest: /etc/file.conf
    owner: bin
    group: wheel
    mode: '0644'
```

从template模块的输出信息中可得知，这是一个用于复制文件模板的模块，能够把文件从Ansible服务器复制到受管主机上。其中，src参数用于定义本地文件的路径，dest参数用于定义复制到受管主机的文件路径，而owner、group、mode参数可选择性地设置文件归属及权限信息。

正常来说，我们可以直接复制文件的操作，受管主机上会获取到一个与Ansible服务器上的文件一模一样的文件。但有时候，我们想让每台客户端根据自身系统的情况产生不同的文件信息，这就需要用到Jinja2技术了，Jinja2格式的模板文件后缀是.j2。

```
[root@linuxprobe apache]# vim tasks/main.yml
---
- name: one
  yum:
          name: httpd
          state: latest
- name: two
  service:
          name: httpd
          state: started
          enabled: yes
- name: three
  firewalld:
          service: http
          permanent: yes
          state: enabled
          immediate: yes
- name: four
  template:
          src: index.html.j2
          dest: /var/www/html/index.html
```

Jinja2是Python语言中一个被广泛使用的模板引擎，最初的设计思想源自Django的模块引擎。Jinja2基于此发展了其语法和一系列强大的功能，能够让受管主机根据自身变量产生出不同的文件内容。换句话说，正常情况下的复制操作会让新旧文件一模一样，但在使用Jinja2技术时，不是在原始文件中直接写入文件内容，而是写入一系列的变量名称。在使用template模块进行复制的过程中，由Ansible服务负责在受管主机上收集这些变量名称所对应的值，然后再逐一填写到目标文件中，从而让每台主机的文件都根据自身系统的情况独立生成。

例如，想要让每个网站的输出信息值为“Welcome to主机名on主机地址”，也就是用每个主机自己独有的名称和IP地址来替换文本中的内容，这样就有趣太多了。这个实验的难点在于查询到对应的变量名称、主机名及地址所对应的值保存在哪里？可以用setup模块进行查询。

```
[root@linuxprobe apache]# ansible-doc setup
> SETUP    (/usr/lib/python3.6/site-packages/ansible/modules/system/setup.py)

        This module is automatically called by playbooks to gather
        useful variables about remote hosts that can be used in
        playbooks. It can also be executed directly by
        `/usr/bin/ansible' to check what variables are available to a
        host. Ansible provides many `facts' about the system,
        automatically. This module is also supported for Windows
        targets.
```

setup模块的作用是自动收集受管主机上的变量信息，使用-a参数外加filter命令可以对收集来的信息进行二次过滤。相应的语法格式为ansible all -m setup -a 'filter="*关键词*"'，其中*号是第3章节讲到的通配符，用于进行关键词查询。例如，如果想搜索各个主机的名称，可以使用通配符搜索所有包含fqdn关键词的变量值信息。

FQDN（Fully Qualified Domain Name，完全限定域名）用于在逻辑上准确表示出主机的位置。FQDN常常被作为主机名的完全表达形式，比/etc/hostname文件中定义的主机名更加严谨和准确。通过输出信息可得知，ansible_fqdn变量保存有主机名称。随后进行下一步操作：

```
[root@linuxprobe ~]# ansible all -m setup -a 'filter="*fqdn*"'
192.168.10.20 | SUCCESS => {
    "ansible_facts": {
        "ansible_fqdn": "linuxprobe.com",
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false
}
………………省略部分输出信息………………
```

用于指定主机地址的变量可以用ip作为关键词进行检索。可以看到，ansible_all_ipv4_addresses变量中的值是我们想要的信息。如果想输出IPv6形式的地址，则可用ansible_all_ipv6_addresses变量。

```
[root@linuxprobe ~]# ansible all -m setup -a 'filter="*ip*"'
192.168.10.20 | SUCCESS => {
    "ansible_facts": {
        "ansible_all_ipv4_addresses": [
            "192.168.10.20",
            "192.168.122.1"
        ],
        "ansible_all_ipv6_addresses": [
            "fe80::d0bb:17c8:880d:e719"
        ],
        "ansible_default_ipv4": {},
        "ansible_default_ipv6": {},
        "ansible_fips": false,
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false
}
………………省略部分输出信息………………
```

在确认了主机名与IP地址所对应的具体变量名称后，在角色所对应的templates目录内新建一个与上面的template模块参数相同的文件名称（index.html.j2）。Jinja2在调用变量值时，格式为在变量名称的两侧格加两个大括号：

```
[root@linuxprobe apache]# vim templates/index.html.j2
Welcome to {{ ansible_fqdn }} on {{ ansible_all_ipv4_addresses }}
```

进行到这里，任务基本就算完成了。最后要做的就是编写一个用于调用apache角色的yml文件，以及执行这个文件。

```
[root@linuxprobe apache]# cd ~
[root@linuxprobe ~]# vim roles.yml
---
- name: 调用自建角色
  hosts: all
  roles:
          - apache
[root@linuxprobe ~]# ansible-playbook roles.yml 
PLAY [调用自建角色] **************************************************************************

TASK [Gathering Facts] **********************************************************************
ok: [192.168.10.20]
ok: [192.168.10.21]
ok: [192.168.10.22]
ok: [192.168.10.23]
ok: [192.168.10.24]

TASK [apache : one] *************************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]
changed: [192.168.10.24]

TASK [apache : two] *************************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]
changed: [192.168.10.24]

TASK [apache : three] ***********************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]
changed: [192.168.10.24]

TASK [apache : four] ***********************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23] 
changed: [192.168.10.24]

PLAY RECAP **********************************************************************************
192.168.10.20   : ok=5   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.21   : ok=5   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.22   : ok=5   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.23   : ok=5   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.24   : ok=4   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0
```

执行完毕后，在浏览器中随机输入几台主机的IP地址，即可访问到包含主机FQDN和IP地址的网页了

<img src="https://cdn.jsdelivr.net/gh/Howietron/Howietron/img/2023/09/1220230912151803.png" alt="1220230912151803" />

实验相当成功！

### **创建和使用逻辑卷**

### **判断主机组名**

### **管理文件属性**

### **管理密码库文件**
